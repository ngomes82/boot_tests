Programming Test Study Outline
=========================================


C++ Specific Questions
--------------------------------


1) Write a Class with two constructors in c++. Have the default constructor use an initialization list.
  Have the other contructor pass in an argument and use assignment. What is the difference? What order will the initialization list follow?
*********************

//Constructor Example in C++
class ConstructorExample
{
	public:
		int Count;
		int* ExampleArr;

		//Example of an initialization list, Order of member decleration is order of initialization.
		ConstructorExample() : Count( 5 ), ExampleArr( new int[Count] )
		{
			std::cout << "Default Constructor Called" << std::endl;
		}

		//Example of an assignment initialization. Initialization occurs just before body of constructor
		//then constructor body executes and assignments occur.
		ConstructorExample(int ArgCount)
		{
			std::cout << "Second Constructor Called" << std::endl;

			Count = ArgCount;
			ExampleArr = new int[Count];
		}
};
//End Constructor Example




2) Add a Copy Constructor to the above class. What is it used for?
*********************

//Constructor Example in C++
class ConstructorExample
{
	public:
		int Count;
		int* ExampleArr;

		//Example of an initialization list, Order of member decleration is order of initialization.
		ConstructorExample() : Count( 5 ), ExampleArr( new int[Count] )
		{
			std::cout << "Default Constructor Called" << std::endl;
		}

		//Example of an assignment initialization. Initialization occurs just before body of constructor
		//then constructor body executes and assignments occur.
		ConstructorExample(int ArgCount)
		{
			std::cout << "Second Constructor Called" << std::endl;

			Count = ArgCount;
			ExampleArr = new int[Count];
		}


		//Copy Constructor, used when assigning or creating 
		//an instance of ConstructionExample using ANOTHER instance of ConstructionExample.
		ConstructorExample(const ConstructorExample& Other) : Count( Other.Count ), ExampleArr( new int[Count] )
		{
			std::cout << "Copy Constructor Called" << std::endl;

			for(int i=0; i<Count; i++)
			{
				ExampleArr[i] = 444;
			}
		}
};
//End Constructor Example


3) Write a series of classes giving us an example of Inheritance in c++. Have three teirs of inheritance,
   a base, a child, and a concrete child. The concrete child should allow no further inheritance of its functions
   or derivations of itself. Show an example of calling a base class funciton in a child classes override.
*********************

//Example of inheritance in c++ 
//Remember in final code the deceleration / definitions of functions will be in different files!
class BaseExample
{

public:
	
	BaseExample(int ArgData)
	{
		data = ArgData;
	}

	int data;

	//Declaring a virtual function.
	virtual int ExampleOverride() { return 10;  }
};

class ChildExample : BaseExample
{
public:
	//Calling the base class constructor. Specific name needs to be used since c++ supports multiple inheritance. No Super.
	ChildExample(int ArgChildData) : BaseExample(ArgChildData){} 

	//Overriding a parent function, also calling the parent. Specific name needs to be used due to multiple inheritance. No Super.
	int ExampleOverride() override { return BaseExample::ExampleOverride() + 10; }
};


//Final class, this class can't be derived from. 
class FinalChildExample final : ChildExample
{

public:
	FinalChildExample() : ChildExample(5) {}

	//final function, the function can not be overridden by children (which can't exist b/c class is final, but this is just an example).
	int ExampleOverride() final override { return ChildExample::ExampleOverride() + 10; } 
};
//END Inheritance examples




4) What is Multiple Inheritance? Why is it useful? Why is it dangerous?
*********************

 Multiple Inheritance allows one class to inherit from multiple base classes.
 It is useful because it allows you to combine properties and functions of multiple classes.
 This is an example of composition/decorator pattern.

 Multiple Inheritance is bad because of the diamond problem. Suppose you make a base class A.
 Then you make two second tier classes (B,C) that inherit from A. 
 Finally you make a class D that inherits from both (B,C) using multiple inheritance.
 Now you make an overridable function on A. Then B and C override that function BUT the final class D DOES NOT.
 If you call D->ExampleOverride()..... what gets called? does it call B::ExampleOverride() or C::ExampleOverride()??? Undefined and ambiguous behaviour.

 



5) Write an example of an interface. Make sure its a fully abstract class with pure virtual functions.
   Describe what an interface, abstract class, and pure virtual fucntion are. Why are interfaces useful?
*********************

//Interface Example
class IExampleInterface
{

public:
	//Pure Virtual Function, any class that derives
	//from this interface is required to override this.
	virtual void ExamplePureVirtualFunc() = 0;

	//Prevents this class from ever being intialized, makes this an abstract class.
	//Abstract classes can never be constructed by themselves, always require derivation.
	virtual ~IExampleInterface() = 0;
};

//Need to Provide implementation of pure virtual destructor
IExampleInterface::~IExampleInterface(){}

class DeriveInterfaceExample : IExampleInterface
{
	//This is required to be implemented!
	void ExamplePureVirtualFunc () 
	{ std::cout << "Example Interface Implementation" << std::endl; }
};

//END Interface Example

//You can use Interfaces instead of multiple inheritance 
//to get a similar composition/decoration utility 
//but without the dangers of multiple inheritance.


6) Show an example of Pass by Value, Pass by Reference and Pass by Pointer.
   What are the differences and when do you use which?
*********************


//Pass by val will copy the argument,
//Then modify the LOCAL Copy only. The
//original, outside of the context will be unchanged.
void PassByValue(int val)
{
	val += 10;
}

//Pass by reference passes a reference to the original
//into the function which allows you to modify the original
// value. Keeps the syntax of a value type so no pointer 
// operations are needed. Useful when you are just modifying the underlying.
void PassByReference(int& val)
{
	val += 10;
}

//Passes in a pointer to the original.
//Requires pointer operations to dereference
//and modify the value. Useful mostly for when you want
//to transfer ownership, you should prefer pass by reference
//if all that's needed is modification of the value.
void PassByPointer(int* val)
{
	(*val) += 20;
}


7) Convert a string to int and vice versa in C++. Use of external lib is allowed.
*********************

//c++ string to int convert using lib
void StringIntConvertUsingSTD()
{

 	std::string str = std::to_string(20);

 	std::cout << str << std::endl;

	int i  = std::stoi("900");

	std::cout << i << std::endl;
}



8) Describe what the keyword const does? When and how is it used? 
	Which of the following are valid uses:

	"const int* p;
	int const* p;
	int* const p;
	const int* const p;
	const int const* p;
	const int const* const p;"

*********************

//Const is used to prevent modificaiton of a value or pointer.
//Use in function and memeber decleration to ensure the 
//value remains un-modified throughout it's use.

void ConstCorrectness()
{
	int i1 = 0;
	int i2 = 1;
	int i3 = 2;
	int i4 = 3;
	int i5 = 4;
	int i6 = 5;

	const int* p1 		= &i1;		  //Pointer to constant int, Value pointed to by p1 CAN'T change.
	int* const p2 		= &i2;		  //Constant Pointer to an int, location pointed by p2 CAN'T change.
	const int* const p3 = &i3;		  //Constant Pointer to a constant int, Value and Location CAN'T Change.

	int const* p4		= &i4;		  // Same as const int*  , but looks and reads weird...
	const int const* p5 = &i5;		  //This works, but is redundant. Duplicate const decleration!
	const int const* const p6 = &i6;  //This works, but is redundant. Duplicate const decleration!


//	(*p1) = 20;  //INVALID
	p1 	  = &i2; //VALID

	(*p2) = 20;  //VALID
//	p2	  = &i1; //INVALID

//	(*p3) = 900; //INVALID
//	p3 	  = &i4; //INVALID
}




9) Describe what a forward decleration is? Why is it useful?
*********************

  Instead of including a full header using:
  		 #include "HeaderFile.h"

  You simply decalre a class instead:
  		class HeaderFile.h;

  This allows the compiler to just treat the uses of that class as a pointer
  in the current file when doing initial header compilation pass.
  This can speed up header compilation times, and can also break cyclic include dependancies.
  It can only be used when the FULL type information of a class is NOT needed in the file.
  E.x. Just having pointer member variables.
  You won't be able to use it if the class depends on the header, in the case of inheritance 
  or struct ownership.




10) What does the explicit keyword do? How do you preform type conversion? What is the difference
	Between static_cast, dynamic_cast, and reintrp_cast?
*********************

//Type Conversion Example
class ExampleImplicitConversion
{

public:
	int data;

	//Since explicit is not used the compiler can do implicit conversions!
	ExampleImplicitConversion( int n ) : data(n) { }
};

class ExampleExplicitConstructor
{

public:
	int data;

	//Since explicit is used no implicit conversions!
	explicit ExampleExplicitConstructor( int n ) : data(n) { }
};

void ConversionExamples()
{
	//Valid, can use constructor implicitly.
	//But will cause '6' to be converted to ASCII int val 54.
	ExampleImplicitConversion ImplicitConvert = '6'; 

	std::cout << "Implicit Convert: " << ImplicitConvert.data << std::endl;

	//INVALID, constructor is explicit!!!
	//ExampleExplicitConstructor ExplicitConvert = '6'; 
	
	//Need to use constructor explicitly!!!!
	ExampleExplicitConstructor ExplicitConstruct(6); 
	
	std::cout << "Explicit Constructor: " << ExplicitConstruct.data << std::endl;


	//TYPE CASTING
	
	//Notes on casting types!!!
	//-----------------------------------

	//static_cast, used for most intuitive literal type conversions.
	//When used for inheritance does NOT return nullptr on invalid casts!!

	//dynamic_cast, used for most polymorphic or inherited casts
	//returns null ptr when fails.

	//const_cast, used to remove const.

	//C style cast (int) - Tries static_cast, then reintp_cast, also applies const_cast if needed.



	int testInt     = 10;
	float testFloat = 0.0f;
 
	int* testIntPtr     = &testInt;
	float* testFloatPrt = &testFloat;

	testFloat = static_cast<float>(testInt); //Valid, you can go from float to int

	std::cout << "Static cast: " << testFloat << std::endl;

	//INVALID, this is conversion doesn't make intuitive sense. 
	//Unless mangled a float* can't point to an int*.

	//testFloatPrt = static_cast<float*>(testIntPtr); 

	//reinterp cast lets you do whatever crazy shit you want!!!
	//this example treats the bits represented by (int)10 directly as a float!!!(1.4104 E-44)
	testFloatPrt = reinterpret_cast<float*>(testIntPtr);

	std::cout << "Reintrp cast: " << (*testFloatPrt) << std::endl;
}

//END Type Conversion Example

