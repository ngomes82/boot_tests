Programming Test Study Outline
=========================================


C++ Specific Questions
--------------------------------


1) Write a Class with two constructors in c++. Have the default constructor use an initialization list.
  Have the other contructor pass in an argument and use assignment. What is the difference? What order will the initialization list follow?
*********************

//Constructor Example in C++
class ConstructorExample
{
	public:
		int Count;
		int* ExampleArr;

		//Example of an initialization list, Order of member decleration is order of initialization.
		ConstructorExample() : Count( 5 ), ExampleArr( new int[Count] )
		{
			std::cout << "Default Constructor Called" << std::endl;
		}

		//Example of an assignment initialization. Initialization occurs just before body of constructor
		//then constructor body executes and assignments occur.
		ConstructorExample(int ArgCount)
		{
			std::cout << "Second Constructor Called" << std::endl;

			Count = ArgCount;
			ExampleArr = new int[Count];
		}
};
//End Constructor Example




2) Add a Copy Constructor to the above class. What is it used for?
*********************

//Constructor Example in C++
class ConstructorExample
{
	public:
		int Count;
		int* ExampleArr;

		//Example of an initialization list, Order of member decleration is order of initialization.
		ConstructorExample() : Count( 5 ), ExampleArr( new int[Count] )
		{
			std::cout << "Default Constructor Called" << std::endl;
		}

		//Example of an assignment initialization. Initialization occurs just before body of constructor
		//then constructor body executes and assignments occur.
		ConstructorExample(int ArgCount)
		{
			std::cout << "Second Constructor Called" << std::endl;

			Count = ArgCount;
			ExampleArr = new int[Count];
		}


		//Copy Constructor, used when assigning or creating 
		//an instance of ConstructionExample using ANOTHER instance of ConstructionExample.
		ConstructorExample(const ConstructorExample& Other) : Count( Other.Count ), ExampleArr( new int[Count] )
		{
			std::cout << "Copy Constructor Called" << std::endl;

			for(int i=0; i<Count; i++)
			{
				ExampleArr[i] = 444;
			}
		}
};
//End Constructor Example


3) Write a series of classes giving us an example of Inheritance in c++. Have three teirs of inheritance,
   a base, a child, and a concrete child. The concrete child should allow no further inheritance of its functions
   or derivations of itself. Show an example of calling a base class funciton in a child classes override.
*********************

//Example of inheritance in c++ 
//Remember in final code the deceleration / definitions of functions will be in different files!
class BaseExample
{

public:
	
	BaseExample(int ArgData)
	{
		data = ArgData;
	}

	int data;

	//Declaring a virtual function.
	virtual int ExampleOverride() { return 10;  }
};

class ChildExample : BaseExample
{
public:
	//Calling the base class constructor. Specific name needs to be used since c++ supports multiple inheritance. No Super.
	ChildExample(int ArgChildData) : BaseExample(ArgChildData){} 

	//Overriding a parent function, also calling the parent. Specific name needs to be used due to multiple inheritance. No Super.
	int ExampleOverride() override { return BaseExample::ExampleOverride() + 10; }
};


//Final class, this class can't be derived from. 
class FinalChildExample final : ChildExample
{

public:
	FinalChildExample() : ChildExample(5) {}

	//final function, the function can not be overridden by children (which can't exist b/c class is final, but this is just an example).
	int ExampleOverride() final override { return ChildExample::ExampleOverride() + 10; } 
};
//END Inheritance examples




4) What is Multiple Inheritance? Why is it useful? Why is it dangerous?
*********************

 Multiple Inheritance allows one class to inherit from multiple base classes.
 It is useful because it allows you to combine properties and functions of multiple classes.
 This is an example of composition/decorator pattern.

 Multiple Inheritance is bad because of the diamond problem. Suppose you make a base class A.
 Then you make two second tier classes (B,C) that inherit from A. 
 Finally you make a class D that inherits from both (B,C) using multiple inheritance.
 Now you make an overridable function on A. Then B and C override that function BUT the final class D DOES NOT.
 If you call D->ExampleOverride()..... what gets called? does it call B::ExampleOverride() or C::ExampleOverride()??? Undefined and ambiguous behaviour.

 



5) Write an example of an interface. Make sure its a fully abstract class with pure virtual functions.
   Describe what an interface, abstract class, and pure virtual fucntion are. Why are interfaces useful?
*********************

//Interface Example
class IExampleInterface
{

public:
	//Pure Virtual Function, any class that derives
	//from this interface is required to override this.
	virtual void ExamplePureVirtualFunc() = 0;

	//Prevents this class from ever being intialized, makes this an abstract class.
	//Abstract classes can never be constructed by themselves, always require derivation.
	virtual ~IExampleInterface() = 0;
};

//Need to Provide implementation of pure virtual destructor
IExampleInterface::~IExampleInterface(){}

class DeriveInterfaceExample : IExampleInterface
{
	//This is required to be implemented!
	void ExamplePureVirtualFunc () 
	{ std::cout << "Example Interface Implementation" << std::endl; }
};

//END Interface Example

//You can use Interfaces instead of multiple inheritance 
//to get a similar composition/decoration utility 
//but without the dangers of multiple inheritance.


6) Show an example of Pass by Value, Pass by Reference and Pass by Pointer.
   What are the differences and when do you use which?
*********************


//Pass by val will copy the argument,
//Then modify the LOCAL Copy only. The
//original, outside of the context will be unchanged.
void PassByValue(int val)
{
	val += 10;
}

//Pass by reference passes a reference to the original
//into the function which allows you to modify the original
// value. Keeps the syntax of a value type so no pointer 
// operations are needed. Useful when you are just modifying the underlying.
void PassByReference(int& val)
{
	val += 10;
}

//Passes in a pointer to the original.
//Requires pointer operations to dereference
//and modify the value. Useful mostly for when you want
//to transfer ownership, you should prefer pass by reference
//if all that's needed is modification of the value.
void PassByPointer(int* val)
{
	(*val) += 20;
}


7) Convert a string to int and vice versa in C++. Use of external lib is allowed.
*********************

//c++ string to int convert using lib
void StringIntConvertUsingSTD()
{

 	std::string str = std::to_string(20);

 	std::cout << str << std::endl;

	int i  = std::stoi("900");

	std::cout << i << std::endl;
}



8) Describe what the keyword const does? When and how is it used? 
	Which of the following are valid uses:

	"const int* p;
	int const* p;
	int* const p;
	const int* const p;
	const int const* p;
	const int const* const p;"

*********************

//When used with a variable:
//Const is used to prevent modificaiton of a value or pointer.
//Use in function and memeber decleration to ensure the 
//value remains un-modified throughout it's use.

void ConstCorrectness()
{
	int i1 = 0;
	int i2 = 1;
	int i3 = 2;
	int i4 = 3;
	int i5 = 4;
	int i6 = 5;

	const int* p1 		= &i1;		  //Pointer to constant int, Value pointed to by p1 CAN'T change.
	int* const p2 		= &i2;		  //Constant Pointer to an int, location pointed by p2 CAN'T change.
	const int* const p3 = &i3;		  //Constant Pointer to a constant int, Value and Location CAN'T Change.

	int const* p4		= &i4;		  // Same as const int*  , but looks and reads weird...
	const int const* p5 = &i5;		  //This works, but is redundant. Duplicate const decleration!
	const int const* const p6 = &i6;  //This works, but is redundant. Duplicate const decleration!


//	(*p1) = 20;  //INVALID
	p1 	  = &i2; //VALID

	(*p2) = 20;  //VALID
//	p2	  = &i1; //INVALID

//	(*p3) = 900; //INVALID
//	p3 	  = &i4; //INVALID
}


//When used with a function, it prevents the funciton from modifying values passed into it.
// ex.   void SomeFunction() const { /* values in this function can't change. */ }



9) Describe what a forward decleration is? Why is it useful?
*********************

  Instead of including a full header using:
  		 #include "HeaderFile.h"

  You simply decalre a class instead:
  		class HeaderFile.h;

  This allows the compiler to just treat the uses of that class as a pointer
  in the current file when doing initial header compilation pass.
  This can speed up header compilation times, and can also break cyclic include dependancies.
  It can only be used when the FULL type information of a class is NOT needed in the file.
  E.x. Just having pointer member variables.
  You won't be able to use it if the class depends on the header, in the case of inheritance 
  or struct ownership.




10) What does the explicit keyword do? How do you preform type conversion? What is the difference
	Between static_cast, dynamic_cast, and reintrp_cast?
*********************

//Type Conversion Example
class ExampleImplicitConversion
{

public:
	int data;

	//Since explicit is not used the compiler can do implicit conversions!
	ExampleImplicitConversion( int n ) : data(n) { }
};

class ExampleExplicitConstructor
{

public:
	int data;

	//Since explicit is used no implicit conversions!
	explicit ExampleExplicitConstructor( int n ) : data(n) { }
};

void ConversionExamples()
{
	//Valid, can use constructor implicitly.
	//But will cause '6' to be converted to ASCII int val 54.
	ExampleImplicitConversion ImplicitConvert = '6'; 

	std::cout << "Implicit Convert: " << ImplicitConvert.data << std::endl;

	//INVALID, constructor is explicit!!!
	//ExampleExplicitConstructor ExplicitConvert = '6'; 
	
	//Need to use constructor explicitly!!!!
	ExampleExplicitConstructor ExplicitConstruct(6); 
	
	std::cout << "Explicit Constructor: " << ExplicitConstruct.data << std::endl;


	//TYPE CASTING
	
	//Notes on casting types!!!
	//-----------------------------------

	//static_cast, used for most intuitive literal type conversions.
	//When used for inheritance does NOT return nullptr on invalid casts!!

	//dynamic_cast, used for most polymorphic or inherited casts
	//returns null ptr when fails.

	//const_cast, used to remove const.

	//C style cast (int) - Tries static_cast, then reintp_cast, also applies const_cast if needed.



	int testInt     = 10;
	float testFloat = 0.0f;
 
	int* testIntPtr     = &testInt;
	float* testFloatPrt = &testFloat;

	testFloat = static_cast<float>(testInt); //Valid, you can go from float to int

	std::cout << "Static cast: " << testFloat << std::endl;

	//INVALID, this is conversion doesn't make intuitive sense. 
	//Unless mangled a float* can't point to an int*.

	//testFloatPrt = static_cast<float*>(testIntPtr); 

	//reinterp cast lets you do whatever crazy shit you want!!!
	//this example treats the bits represented by (int)10 directly as a float!!!(1.4104 E-44)
	testFloatPrt = reinterpret_cast<float*>(testIntPtr);

	std::cout << "Reintrp cast: " << (*testFloatPrt) << std::endl;
}

//END Type Conversion Example


11) What do the mutable, volatile, and atomic keywords signify?
*********************

	-Mutable allows member variables of a class or struct to be changed EVEN WITHIN const functions!


	-Volatile signifies to the compiler that some EXTERNAL process may modify a value, so don't event try to optimize it (the compiler may remove a value deemed un-necessary during optimization.)



	-Atomic types are types that encapsulate a value whose access is guaranteed to not cause data races and can be used to synchronize memory accesses among different threads

	Objects of atomic types are the only C++ objects that are free from data races; that is, if one thread writes to an atomic object while another thread reads from it, the behavior is well-defined.

	In addition, accesses to atomic objects may establish inter-thread synchronization and order non-atomic memory accesses as specified by std::memory_order. These operations will be performed with std::memory_order_seq_cst, as this is the default order for all atomic operations in C++ 11.




12) What is an inline function? What is the magnitude of the speed difference between inline, direct, and virtual calls? Why would certain calls take much longer?
*********************

Pros:
When an inline keyword is used for a function it tells the compiler to direclty copy the contents of
a function 'inline' with wherever its called. This is opposed to just doing a direction function call(jumping).
This has the benefit of avoiding a function call overhead and pushing/poping variables.
Also this increases the locality of data and instructions used by the call, allowing for CPU to prefetch better.

cons:
This increases overall executable size. 
Can also increase compile times, since any code using an inline NEEDS to be recompiled 
(can't just jump to newly compiled funciton!)
B/c of increased executable size at call, may result in possible trashing if increased too large and casues page faults.

Speed Magnitudes:

3GHz in-order PowerPC CPU
1024 float vector3's  (fits in L1)  with 1000 additions:

inline  ~8ms
direct  ~68ms
virtual ~160ms

direct call takes longer because of one level of indirection needed. So CPU misses instruction prefetch once.
virtual calls takes even longer because of two levels of indirection. So CPU misses instruciton prefetch twice, AND needs to load data from the class that it's calling, so possible data cache miss.





13) What are the new and delete keywords used for? What is the difference between a shared_ptr, weak_ptr, and a unique_ptr?
*********************


The new keyword is used to request memory allocation from the language (off the heap) or if its large gets a full memory Page (from the OS).  The os gives our application 
some pages of virtual memory so new returns a virtual memory address that is within the 
application's range that maps to some physical memory in RAM. 
Delete is used to tell the language/OS to free/deallocate memory from use.

These work with raw pointers which needs all of its memory managed by 
hand and must be deleted when appropriate.

There are smart pointers which help memory management by using reference counting.

A unique_ptr represents a one owner pointer. 
Only the single owner can use the pointer. 
The pointer is cleaned up when that single owner leaves scope or is destructed.
It needs to be moved explicitly.

A shared_ptr keeps a reference counter and increments it whenever the pointer is passed. It decrements the counter
whenever the pointer leaves scope of a class or function. Once the coutner reaches 0, the pointer is automatically
flagged for deletion. Can cause issues with cyclic dependencies or data structs.

A weak_ptr just observes a pointer but does not increment its counter. It can become invalid.
So you much check if the underlying pointer has expired. 


14) Show an example of using a function pointer as a callback, delegate, or event. 
*********************

float ExampleDelegateConcreteFunc1(float arg)
{
	return (arg + 9.0f);
}

float ExampleDelegateConcreteFunc2(float arg)
{
	return (arg + 20.0f);
}

typedef float (*ExampleDelegate) (float arg);


void ExampleDelegateRun()
{
	float original = 20.0f;

	ExampleDelegate function = &ExampleDelegateConcreteFunc1;

	std::cout << "delegate1: " << function(original) << std::endl;

	function = &ExampleDelegateConcreteFunc2;

	std::cout << "delegate2: " << function(original) << std::endl;
}




15) What do the keywords  "extern c" signify?
*********************



