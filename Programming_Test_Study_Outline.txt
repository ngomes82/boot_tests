Programming Test Study Outline
=========================================


C++ Specific Questions
--------------------------------


1) Write a Class with two constructors in c++. Have the default constructor use an initialization list.
  Have the other contructor pass in an argument and use assignment. What is the difference? What order will the initialization list follow?
*********************

//Constructor Example in C++
class ConstructorExample
{
	public:
		int Count;
		int* ExampleArr;

		//Example of an initialization list, Order of member decleration is order of initialization.
		ConstructorExample() : Count( 5 ), ExampleArr( new int[Count] )
		{
			std::cout << "Default Constructor Called" << std::endl;
		}

		//Example of an assignment initialization. Initialization occurs just before body of constructor
		//then constructor body executes and assignments occur.
		ConstructorExample(int ArgCount)
		{
			std::cout << "Second Constructor Called" << std::endl;

			Count = ArgCount;
			ExampleArr = new int[Count];
		}
};
//End Constructor Example




2) Add a Copy Constructor to the above class. What is it used for?
*********************

//Constructor Example in C++
class ConstructorExample
{
	public:
		int Count;
		int* ExampleArr;

		//Example of an initialization list, Order of member decleration is order of initialization.
		ConstructorExample() : Count( 5 ), ExampleArr( new int[Count] )
		{
			std::cout << "Default Constructor Called" << std::endl;
		}

		//Example of an assignment initialization. Initialization occurs just before body of constructor
		//then constructor body executes and assignments occur.
		ConstructorExample(int ArgCount)
		{
			std::cout << "Second Constructor Called" << std::endl;

			Count = ArgCount;
			ExampleArr = new int[Count];
		}


		//Copy Constructor, used when assigning or creating 
		//an instance of ConstructionExample using ANOTHER instance of ConstructionExample.
		ConstructorExample(const ConstructorExample& Other) : Count( Other.Count ), ExampleArr( new int[Count] )
		{
			std::cout << "Copy Constructor Called" << std::endl;

			for(int i=0; i<Count; i++)
			{
				ExampleArr[i] = 444;
			}
		}
};
//End Constructor Example


3) Write a series of classes giving us an example of Inheritance in c++. Have three teirs of inheritance,
   a base, a child, and a concrete child. The concrete child should allow no further inheritance of its functions
   or derivations of itself. Show an example of calling a base class funciton in a child classes override.
*********************

//Example of inheritance in c++ 
//Remember in final code the deceleration / definitions of functions will be in different files!
class BaseExample
{

public:
	
	BaseExample(int ArgData)
	{
		data = ArgData;
	}

	int data;

	//Declaring a virtual function.
	virtual int ExampleOverride() { return 10;  }
};

class ChildExample : BaseExample
{
public:
	//Calling the base class constructor. Specific name needs to be used since c++ supports multiple inheritance. No Super.
	ChildExample(int ArgChildData) : BaseExample(ArgChildData){} 

	//Overriding a parent function, also calling the parent. Specific name needs to be used due to multiple inheritance. No Super.
	int ExampleOverride() override { return BaseExample::ExampleOverride() + 10; }
};


//Final class, this class can't be derived from. 
class FinalChildExample final : ChildExample
{

public:
	FinalChildExample() : ChildExample(5) {}

	//final function, the function can not be overridden by children (which can't exist b/c class is final, but this is just an example).
	int ExampleOverride() final override { return ChildExample::ExampleOverride() + 10; } 
};
//END Inheritance examples




4) What is Multiple Inheritance? Why is it useful? Why is it dangerous?
*********************

 Multiple Inheritance allows one class to inherit from multiple base classes.
 It is useful because it allows you to combine properties and functions of multiple classes.
 This is an example of composition/decorator pattern.

 Multiple Inheritance is bad because of the diamond problem. Suppose you make a base class A.
 Then you make two second tier classes (B,C) that inherit from A. 
 Finally you make a class D that inherits from both (B,C) using multiple inheritance.
 Now you make an overridable function on A. Then B and C override that function BUT the final class D DOES NOT.
 If you call D->ExampleOverride()..... what gets called? does it call B::ExampleOverride() or C::ExampleOverride()??? Undefined and ambiguous behaviour.

 



5) Write an example of an interface. Make sure its a fully abstract class with pure virtual functions.
   Describe what an interface, abstract class, and pure virtual fucntion are. Why are interfaces useful?
*********************

//Interface Example
class IExampleInterface
{

public:
	//Pure Virtual Function, any class that derives
	//from this interface is required to override this.
	virtual void ExamplePureVirtualFunc() = 0;

	//Prevents this class from ever being intialized, makes this an abstract class.
	//Abstract classes can never be constructed by themselves, always require derivation.
	virtual ~IExampleInterface() = 0;
};

//Need to Provide implementation of pure virtual destructor
IExampleInterface::~IExampleInterface(){}

class DeriveInterfaceExample : IExampleInterface
{
	//This is required to be implemented!
	void ExamplePureVirtualFunc () 
	{ std::cout << "Example Interface Implementation" << std::endl; }
};

//END Interface Example

//You can use Interfaces instead of multiple inheritance 
//to get a similar composition/decoration utility 
//but without the dangers of multiple inheritance.


6) Show an example of Pass by Value, Pass by Reference and Pass by Pointer.
   What are the differences and when do you use which?
*********************


//Pass by val will copy the argument,
//Then modify the LOCAL Copy only. The
//original, outside of the context will be unchanged.
void PassByValue(int val)
{
	val += 10;
}

//Pass by reference passes a reference to the original
//into the function which allows you to modify the original
// value. Keeps the syntax of a value type so no pointer 
// operations are needed. Useful when you are just modifying the underlying.
void PassByReference(int& val)
{
	val += 10;
}

//Passes in a pointer to the original.
//Requires pointer operations to dereference
//and modify the value. Useful mostly for when you want
//to transfer ownership, you should prefer pass by reference
//if all that's needed is modification of the value.
void PassByPointer(int* val)
{
	(*val) += 20;
}


7) Convert a string to int and vice versa in C++. Use of external lib is allowed.
*********************

//c++ string to int convert using lib
void StringIntConvertUsingSTD()
{

 	std::string str = std::to_string(20);

 	std::cout << str << std::endl;

	int i  = std::stoi("900");

	std::cout << i << std::endl;
}



8) Describe what the keyword const does? When and how is it used? 
	Which of the following are valid uses:

	"const int* p;
	int const* p;
	int* const p;
	const int* const p;
	const int const* p;
	const int const* const p;"

*********************

//When used with a variable:
//Const is used to prevent modificaiton of a value or pointer.
//Use in function and memeber decleration to ensure the 
//value remains un-modified throughout it's use.

void ConstCorrectness()
{
	int i1 = 0;
	int i2 = 1;
	int i3 = 2;
	int i4 = 3;
	int i5 = 4;
	int i6 = 5;

	const int* p1 		= &i1;		  //Pointer to constant int, Value pointed to by p1 CAN'T change.
	int* const p2 		= &i2;		  //Constant Pointer to an int, location pointed by p2 CAN'T change.
	const int* const p3 = &i3;		  //Constant Pointer to a constant int, Value and Location CAN'T Change.

	int const* p4		= &i4;		  // Same as const int*  , but looks and reads weird...
	const int const* p5 = &i5;		  //This works, but is redundant. Duplicate const decleration!
	const int const* const p6 = &i6;  //This works, but is redundant. Duplicate const decleration!


//	(*p1) = 20;  //INVALID
	p1 	  = &i2; //VALID

	(*p2) = 20;  //VALID
//	p2	  = &i1; //INVALID

//	(*p3) = 900; //INVALID
//	p3 	  = &i4; //INVALID
}


//When used with a function, it prevents the funciton from modifying values passed into it.
// ex.   void SomeFunction() const { /* values in this function can't change. */ }



9) Describe what a forward decleration is? Why is it useful?
*********************

  Instead of including a full header using:
  		 #include "HeaderFile.h"

  You simply decalre a class instead:
  		class HeaderFile;

  This allows the compiler to just treat the uses of that class as a pointer
  in the current file when doing initial header compilation pass.
  This can speed up header compilation times, and can also break cyclic include dependancies.
  It can only be used when the FULL type information of a class is NOT needed in the file.
  E.x. Just having pointer member variables.
  You won't be able to use it if the class depends on the header, in the case of inheritance 
  or struct ownership.




10) What does the explicit keyword do? How do you preform type conversion? What is the difference
	Between static_cast, dynamic_cast, and reintrp_cast?
*********************

//Type Conversion Example
class ExampleImplicitConversion
{

public:
	int data;

	//Since explicit is not used the compiler can do implicit conversions!
	ExampleImplicitConversion( int n ) : data(n) { }
};

class ExampleExplicitConstructor
{

public:
	int data;

	//Since explicit is used no implicit conversions!
	explicit ExampleExplicitConstructor( int n ) : data(n) { }
};

void ConversionExamples()
{
	//Valid, can use constructor implicitly.
	//But will cause '6' to be converted to ASCII int val 54.
	ExampleImplicitConversion ImplicitConvert = '6'; 

	std::cout << "Implicit Convert: " << ImplicitConvert.data << std::endl;

	//INVALID, constructor is explicit!!!
	//ExampleExplicitConstructor ExplicitConvert = '6'; 
	
	//Need to use constructor explicitly!!!!
	ExampleExplicitConstructor ExplicitConstruct(6); 
	
	std::cout << "Explicit Constructor: " << ExplicitConstruct.data << std::endl;


	//TYPE CASTING
	
	//Notes on casting types!!!
	//-----------------------------------

	//static_cast, used for most intuitive literal type conversions.
	//When used for inheritance does NOT return nullptr on invalid casts!!

	//dynamic_cast, used for most polymorphic or inherited casts
	//returns null ptr when fails.

	//const_cast, used to remove const.

	//C style cast (int) - Tries static_cast, then reintp_cast, also applies const_cast if needed.



	int testInt     = 10;
	float testFloat = 0.0f;
 
	int* testIntPtr     = &testInt;
	float* testFloatPrt = &testFloat;

	testFloat = static_cast<float>(testInt); //Valid, you can go from float to int

	std::cout << "Static cast: " << testFloat << std::endl;

	//INVALID, this is conversion doesn't make intuitive sense. 
	//Unless mangled a float* can't point to an int*.

	//testFloatPrt = static_cast<float*>(testIntPtr); 

	//reinterp cast lets you do whatever crazy shit you want!!!
	//this example treats the bits represented by (int)10 directly as a float!!!(1.4104 E-44)
	testFloatPrt = reinterpret_cast<float*>(testIntPtr);

	std::cout << "Reintrp cast: " << (*testFloatPrt) << std::endl;
}

//END Type Conversion Example


11) What do the mutable, volatile, and atomic keywords signify?
*********************

	-Mutable allows member variables of a class or struct to be changed EVEN WITHIN const functions!


	-Volatile signifies to the compiler that some EXTERNAL process may modify a value, so don't event try to optimize it (the compiler may remove a value deemed un-necessary during optimization.)



	-Atomic types are types that encapsulate a value whose access is guaranteed to not cause data races and can be used to synchronize memory accesses among different threads

	Objects of atomic types are the only C++ objects that are free from data races; that is, if one thread writes to an atomic object while another thread reads from it, the behavior is well-defined.

	In addition, accesses to atomic objects may establish inter-thread synchronization and order non-atomic memory accesses as specified by std::memory_order. These operations will be performed with std::memory_order_seq_cst, as this is the default order for all atomic operations in C++ 11.




12) What is an inline function? What is the magnitude of the speed difference between inline, direct, and virtual calls? Why would certain calls take much longer?
*********************

Pros:
When an inline keyword is used for a function it tells the compiler to direclty copy the contents of
a function 'inline' with wherever its called. This is opposed to just doing a direction function call(jumping).
This has the benefit of avoiding a function call overhead and pushing/poping variables.
Also this increases the locality of data and instructions used by the call, allowing for CPU to prefetch better.

cons:
This increases overall executable size. 
Can also increase compile times, since any code using an inline NEEDS to be recompiled 
(can't just jump to newly compiled funciton!)
B/c of increased executable size at call, may result in possible trashing if increased too large and casues page faults.

Speed Magnitudes:

3GHz in-order PowerPC CPU
1024 float vector3's  (fits in L1)  with 1000 additions:

inline  ~8ms
direct  ~68ms
virtual ~160ms

direct call takes longer because of one level of indirection needed. So CPU misses instruction prefetch once.
virtual calls takes even longer because of two levels of indirection. So CPU misses instruciton prefetch twice, AND needs to load data from the class that it's calling, so possible data cache miss.





13) What are the new and delete keywords used for? What is the difference between a shared_ptr, weak_ptr, and a unique_ptr?
*********************


The new keyword is used to request memory allocation from the language (off the heap) or if its large gets a full memory Page (from the OS).  The os gives our application 
some pages of virtual memory so new returns a virtual memory address that is within the 
application's range that maps to some physical memory in RAM. 
Delete is used to tell the language/OS to free/deallocate memory from use.

These work with raw pointers which needs all of its memory managed by 
hand and must be deleted when appropriate.

There are smart pointers which help memory management by using reference counting.

A unique_ptr represents a one owner pointer. 
Only the single owner can use the pointer. 
The pointer is cleaned up when that single owner leaves scope or is destructed.
It needs to be moved explicitly.

A shared_ptr keeps a reference counter and increments it whenever the pointer is passed. It decrements the counter
whenever the pointer leaves scope of a class or function. Once the coutner reaches 0, the pointer is automatically
flagged for deletion. Can cause issues with cyclic dependencies or data structs.

A weak_ptr just observes a pointer but does not increment its counter. It can become invalid.
So you much check if the underlying pointer has expired. 


14) Show an example of using a function pointer as a callback, delegate, or event. 
*********************

float ExampleDelegateConcreteFunc1(float arg)
{
	return (arg + 9.0f);
}

float ExampleDelegateConcreteFunc2(float arg)
{
	return (arg + 20.0f);
}

typedef float (*ExampleDelegate) (float arg);


void ExampleDelegateRun()
{
	float original = 20.0f;

	ExampleDelegate function = &ExampleDelegateConcreteFunc1;

	std::cout << "delegate1: " << function(original) << std::endl;

	function = &ExampleDelegateConcreteFunc2;

	std::cout << "delegate2: " << function(original) << std::endl;
}


15) What do the keywords  "extern c" signify?
*********************

when used with a function decleration:
 	extern "C" void func(int);

 Makes a function name in C++ have a C linkage.
 That means the compiler does not mangle the name of the function. 
 Which allows client C code to link and
 use your function by using a compatible header file that contains just
 the decleration of that function.


 16) What does the auto keyword mean in c++? 
     Use it with an iterator to loop over a std container.
 *********************

 //The auto keyword allows the type of the variable being delcared to be
 // automatically interpreted from its initializer.

 void RunItrExample()
{
	std::vector<int> myIntVec;

	myIntVec.push_back(1);
	myIntVec.push_back(5);
	myIntVec.push_back(8);

	for( auto iterator = myIntVec.begin(); 
		 iterator != myIntVec.end(); 
		 iterator++ )
	{
		std::cout << (*iterator) << " ";
	}

	std::cout << " iteraror!" << std::endl;
}


17) What is a namespace? When should it be used?
*********************

A namespace provides a method to place classes, functions, and variables  within a higher level scope.
This is useful to avoid naming conflicts within large projects or when importing external libraries.

You can identify namespace in each call by placing the namespace preceding 
the use of the object in the namespace  e.x.  std::cout, std::rand()... etc.


You can also specify the namespace to use within the header and sub-headers by placing a "using" decleration:

	//Dangerous! includes whole namespace, could lead to conflicts in sub-headers!!
	using namespace std; 

	//Type aliasing, Locally re-identify an object. Could lead to conflicts in sub-headers!!
	templace<class T>
	using MyVector<T> = std::vector<T>;



18) Name some STD data containers and their underlying data structure representation.
*********************

	std::array  		(statically sized array, contiguous) [c++11]
	std::vector 		(dynamically sized array, contiguous)
	std::deque			(double ended queue, non-contiguous)
	std::forward_list 	(single linked list, non-contiguous) [c++11]
	std::list			(doubly linked list, non-contiguous)

	std::stack			
	std::queue

	//Ordered associative containers. Sorted with BST, you can iterate!
	std::set 			(hashtable where value is key, uniqueness garunteed)
	std::multiset		(hashtable where value is key, multiples allowed)
	std::map 			(hashtable key=>value, uniqueness garunteed)
	std::multimap	    (hashtable key=>value, multiples allowed)

	//Unordered versions are just unordered_X  (faster to access, can't directly iterate)



19) Whats the difference between a struct and a class?
*********************
For the most part, nothing.
You can do anything with a struct that you can do with a class.

The only real difference:
Structs are public by default. 
Classes are private by default.


In practice (depends on the company):

Structs are generally used to represent 
smaller types that mostly consist of plain old data.

Class are generally larger and represent more functionality.


20) Give an example of using a template. How do they work udner the hood?
	What are the pros and cons of using templates?
*********************

template<class t1>
class TemplatedLinkedListNode
{

public:

	explicit TemplatedLinkedListNode(t1 argData) : data(argData), Next(nullptr) {}

	TemplatedLinkedListNode *Next;
	t1 data;
};

void RunTemplateExample()
{
	TemplatedLinkedListNode<int> n1 (10);
	TemplatedLinkedListNode<int> n2 (20);
	TemplatedLinkedListNode<int> n3 (40);

	n1.Next = &n2;
	n2.Next = &n3;

	TemplatedLinkedListNode<int>* current = &n1;

	while(current != nullptr)
	{
		std::cout << "template node: " << current->data << " ";
		current = current->Next;
	}

	std::cout << std::endl;
}


//Templates allow for the same code to be used for many differing types of objects
//Increasing the code's modularity and usability.
//The compiler duplicates the template code across all 
//the types that it finds using the template. 
//New code is generated for each new type that the compiler encounters.
//This can cause both the compile time and executable size to increase significantly.



21) Describe some integral data types and their sizes and max capacities
*********************

bool   (1 byte)  (8 bits)  [256 max 2^8]
char   (1 byte)
short  (2 bytes) (16 bits)  
ushort (2 bytes)			[65,536 max 2^16]
int    (4 bytes) (32 bits)  //At least 2 bytes, can be 4 bytes, compiler target specific
float  (4 bytes) 
uint   (4 bytes)			[4,294,967,296 max 2^32]
long   (4 bytes) //At least 4 bytes
ulong  (4 bytes)			
double (8 bytes) (64 bits)
int64  (8 bytes)
long double (8 bytes)
long long   (8 bytes) //at least 8 bytes
long ulong  (8bytes)			[18,446,744,073,709,551,616 max 2^64]


22) Give an example of operator overloading.
*********************


class ComplexNum
{

private:
	ComplexNum(){}

public:
	int real;
	int imaginary;

	ComplexNum(int argReal, int argImaginary): real(argReal), imaginary(argImaginary){}

	ComplexNum operator + (ComplexNum const &obj)
	{
		ComplexNum res;
		res.real 		= real + obj.real;
		res.imaginary   = imaginary + obj.imaginary;

		return res;
	}
};

void RunOperatorOverloadTest()
{
	ComplexNum c1 (10, 5);
	ComplexNum c2 (2, 4);

	ComplexNum c3 = c1 + c2;

	std::cout << "overload: " << c3.real << "," << c3.imaginary << std::endl;
}




3D Math Specific Questions
--------------------------------


23) Describe what a vector is in 3d space?
*********************
	A vector is a representation of a direction with a magnitude. 
	It has no origin and represents the same direction and magnitude 
	throughout the entire space. 

	You can add and subtract vectors to points to move them. 
	Subtracting two points from one another gives a vector
	representing the displacement.

	P1 (xp1, yp1, zp1) 
	P2 (xp2, yp2, zp2)

	P2 - P1 = Vd (Displacement vector, pointing from P1 towards P2)


	Adding two vectors places them head to tail with
	the resulting addition being the vector that meets the combined tail to
	the combined head. Subtracting two vectors places them tail to tail with
	the resulting subtraction being the vector that meets from one head to the other.

	A unit vector is a vector with  a total magnitude of 1.0.

	V1 <x1, y1, z1>    V2 <x2, y2, z2> 

	V1 + V2 = <x1+x2, y1+y2, z1+z2>


24) What is the magnitude of a vector? How do you compute it?
*********************

	The magnitude of a vector is the scalar length of the vector.
	If mulitplied into a Unit Vector would give you the same vector
	that you got the magnitude from.

	To calculate the magnitude of a vector:

	|A| = sqrt( Ax^2 + Ay^2 + Az^2)


25) What does it mean to normalize a vector? How do you compute it?
*********************
	Normalizing a vector means to make the total magnitude of
	the original vector length 1. This means the vector represents
	purely a direction without any addition magnitue (unit length).

	To compute it first you find the vector's Magnitude |A|.
	Then you preform the following:

	Ax = Ax / |A|
	Ay = Ay / |A|
	Az = Az / |A|



26) What is a vector dot product? How do you calculate it?
*********************

The vector dot product takes two vectors and computes 
the length of the projection of one onto the other.

To calculate the Dot product:

A • B = (Ax + Bx) * (Ay + By) * (Az + Bz)


In addition, it's geometric defintion can be represented as:

A • B = |A| * |B| * cos(Θ)

Where theta is the angle between the vectors.



27) What is a vector cross product? How do you calculate it?
*********************

A cross product between two vectors gives you a third vector
that is perpendicular to both. Since there can be two of these
(upfacing and downfacing) you need to choose if the space is
right hand oriented vs left hand oriented and choose accordingly.

upface: 	AxB
downface:   BxA == -AxB

To calculate the Cross product:

AxB = < Ay*Bz - Az*By, Az*Bx - Ax*Bz, Ax*By - Ay*Bx>


In addition, it's geometric definition can be represented as:

AxB = |A| * |B| * sin(Θ) * n

where theta is the angle between A and B
where n is the unit vector perpendicular to both A and B


28) Find the angle between two vectors (A,B).
*********************

First find the magnitudes of A and B (|A| |B|).
Then calculate their dot product (D).

Using the geometric definition of a dot product we can find the angle.

D = |A|*|B|*cos(Θ)

D / (|A||B|) = cos(Θ)

Θ = arccos ( D / (|A||B|) )


29) Multiply a single scalar value (s) into a vector (A)
*********************

s * A = < s * Ax, s * Ay, s * Az>


30) Given three non-colinear points (Pa, Pb, Pc)
	Create a representation of a plane.
*********************

	A plane requires a normal to represent its slope.
	So first we need to get two vectors on the plane to do a cross product.

	Va = Pa - Pb
	Vc = Pc - Pb

	Vn = Va x Vc

	Normalize Vn, this is the normal of the plane.

equation of a plane is:

ax + by + cz = d    [a,b,c] is the normal

Then use the normal vector and any point to find the final determinant d.


31) Given a formula for a plane and a vector (V).
	Find the projection of that vector onto the plane.
*********************

equation of a plane is:

ax + by + cz = d

So the plane normal Pn = <a,b,c>

To find the projection:

First we take the dot product of the
vector and the normal to find the magnitude of the projection.
(V • Pn)   <------ scalar representing magnitude.

Then we subtract the original vector from the planes normal vector 
to get the direction of the projection along the plane. 
(Line up the tails, and find the vector between the heads)

V - Pn   <--- vector representing direction along plane.


Finally we combine the two giving us the final equation:

Projection = (V - Pn) * (V • Pn)



32) Given a plane normal (Pn), a point on that plane (P1), 
	and a second arbitrary point(P2).
    Can you find out what side of the plane the point lies on.
*********************

	First find the vector between P2 and P1.

	Dv = P2 - P1

	Then take the dot product of that and the Plane normal

	CrossP = Pn • Dv


	If its + then its on the side of the normal.
	If its - then its opposite the normal.
	If its 0 then the point is ON the plane.


33) Given two spheres in 3d space (represented by center point and radius)
	Sc1 (x,y,z) Sr1   and  Sc2 (x,y,z) Sr2 
    Find out if they overlap.
*********************


The equation of a sphere with center (h,j,k) and radius r :

(x - h)2 + (y - j)2 + (z - k)2 = r2


But we can just find the displacement of the center's Sc1 - Sc2
Then get the magnitude of the displacement

|Sc1 - Sc2|

Then compare by adding the two sphere radii
|Sc1 - Sc2| - (Sr1 + Sr2)

If the result is + then they don't overlap
If the result is - then they overlap
If the result is 0 then they are exactly touching.



34) Point to AABB Overlap
*********************

Simply get the displacement from point to sphere center.
Then check its magnitude against radius. 

If larger then its not overlapping.
If smaller then its overlapping.
If 0 then its on the sphere.


35) AABB to Sphere Overlap
*********************

You could check all points but this is overkill.
Find the point CLOSEST to the sphere center.

Then run a Point to AABB overlap on that closest point.

If the box is not axis alinged, then you rotate the sphere
such that it becomes axis alinged with the box, 
then run the overlap test.


36) AABB to AABB Overlap
*********************

 Similar to the point to AABB Overlap test, but we need to do one test
 PER Axis. Check the min and max of each axis point againt one another.

 So it looks like:

Instersects(A,B)=     (AminX <= BmaxX && AmaxX >= BminX)
		 		   && (AminY <= BmaxY && AmaxY >= BminY)
		 		   && (AminZ <= BmaxZ && AmaxZ >= BminZ)



37) What is a Quaternion? Why is it useful?
    Show how to convert between the following:
    	Angle Axis     <=> Quat
    	Euler Angles   <=> Quat
    	4x4 Rot Matrix <=> Quat

    Describe these:
    	Identity Quat
    	How to combine Quats?
    	How to find inverse of a Quat? Why its useful?
*********************





