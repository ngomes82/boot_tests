Programming Test Study Outline
=========================================


C++ Specific Questions
--------------------------------


1) Write a Class with two constructors in c++. Have the default constructor use an initialization list.
  Have the other contructor pass in an argument and use assignment. What is the difference? What order will the initialization list follow?
*********************

//Constructor Example in C++
class ConstructorExample
{
	public:
		int Count;
		int* ExampleArr;

		//Example of an initialization list, Order of member decleration is order of initialization.
		ConstructorExample() : Count( 5 ), ExampleArr( new int[Count] )
		{
			std::cout << "Default Constructor Called" << std::endl;
		}

		//Example of an assignment initialization. Initialization occurs just before body of constructor
		//then constructor body executes and assignments occur.
		ConstructorExample(int ArgCount)
		{
			std::cout << "Second Constructor Called" << std::endl;

			Count = ArgCount;
			ExampleArr = new int[Count];
		}
};
//End Constructor Example




2) Add a Copy Constructor to the above class. What is it used for?
*********************

//Constructor Example in C++
class ConstructorExample
{
	public:
		int Count;
		int* ExampleArr;

		//Example of an initialization list, Order of member decleration is order of initialization.
		ConstructorExample() : Count( 5 ), ExampleArr( new int[Count] )
		{
			std::cout << "Default Constructor Called" << std::endl;
		}

		//Example of an assignment initialization. Initialization occurs just before body of constructor
		//then constructor body executes and assignments occur.
		ConstructorExample(int ArgCount)
		{
			std::cout << "Second Constructor Called" << std::endl;

			Count = ArgCount;
			ExampleArr = new int[Count];
		}


		//Copy Constructor, used when assigning or creating 
		//an instance of ConstructionExample using ANOTHER instance of ConstructionExample.
		ConstructorExample(const ConstructorExample& Other) : Count( Other.Count ), ExampleArr( new int[Count] )
		{
			std::cout << "Copy Constructor Called" << std::endl;

			for(int i=0; i<Count; i++)
			{
				ExampleArr[i] = 444;
			}
		}
};
//End Constructor Example


3) Write a series of classes giving us an example of Inheritance in c++. Have three teirs of inheritance,
   a base, a child, and a concrete child. The concrete child should allow no further inheritance of its functions
   or derivations of itself. Show an example of calling a base class funciton in a child classes override.
*********************

//Example of inheritance in c++ 
//Remember in final code the deceleration / definitions of functions will be in different files!
class BaseExample
{

public:
	
	BaseExample(int ArgData)
	{
		data = ArgData;
	}

	int data;

	//Declaring a virtual function.
	virtual int ExampleOverride() { return 10;  }
};

class ChildExample : BaseExample
{
public:
	//Calling the base class constructor. Specific name needs to be used since c++ supports multiple inheritance. No Super.
	ChildExample(int ArgChildData) : BaseExample(ArgChildData){} 

	//Overriding a parent function, also calling the parent. Specific name needs to be used due to multiple inheritance. No Super.
	int ExampleOverride() override { return BaseExample::ExampleOverride() + 10; }
};


//Final class, this class can't be derived from. 
class FinalChildExample final : ChildExample
{

public:
	FinalChildExample() : ChildExample(5) {}

	//final function, the function can not be overridden by children (which can't exist b/c class is final, but this is just an example).
	int ExampleOverride() final override { return ChildExample::ExampleOverride() + 10; } 
};
//END Inheritance examples




4) What is Multiple Inheritance? Why is it useful? Why is it dangerous?
*********************

 Multiple Inheritance allows one class to inherit from multiple base classes.
 It is useful because it allows you to combine properties and functions of multiple classes.
 This is an example of composition/decorator pattern.

 Multiple Inheritance is bad because of the diamond problem. Suppose you make a base class A.
 Then you make two second tier classes (B,C) that inherit from A. 
 Finally you make a class D that inherits from both (B,C) using multiple inheritance.
 Now you make an overridable function on A. Then B and C override that function BUT the final class D DOES NOT.
 If you call D->ExampleOverride()..... what gets called? does it call B::ExampleOverride() or C::ExampleOverride()??? Undefined and ambiguous behaviour.

 



5) Write an example of an interface. Make sure its a fully abstract class with pure virtual functions.
   Describe what an interface, abstract class, and pure virtual fucntion are. Why are interfaces useful?
*********************

//Interface Example
class IExampleInterface
{

public:
	//Pure Virtual Function, any class that derives
	//from this interface is required to override this.
	virtual void ExamplePureVirtualFunc() = 0;

	//Prevents this class from ever being intialized, makes this an abstract class.
	//Abstract classes can never be constructed by themselves, always require derivation.
	virtual ~IExampleInterface() = 0;
};

//Need to Provide implementation of pure virtual destructor
IExampleInterface::~IExampleInterface(){}

class DeriveInterfaceExample : IExampleInterface
{
	//This is required to be implemented!
	void ExamplePureVirtualFunc () 
	{ std::cout << "Example Interface Implementation" << std::endl; }
};

//END Interface Example

//You can use Interfaces instead of multiple inheritance 
//to get a similar composition/decoration utility 
//but without the dangers of multiple inheritance.


6) Show an example of Pass by Value, Pass by Reference and Pass by Pointer.
   What are the differences and when do you use which?
*********************


//Pass by val will copy the argument,
//Then modify the LOCAL Copy only. The
//original, outside of the context will be unchanged.
void PassByValue(int val)
{
	val += 10;
}

//Pass by reference passes a reference to the original
//into the function which allows you to modify the original
// value. Keeps the syntax of a value type so no pointer 
// operations are needed. Useful when you are just modifying the underlying.
void PassByReference(int& val)
{
	val += 10;
}

//Passes in a pointer to the original.
//Requires pointer operations to dereference
//and modify the value. Useful mostly for when you want
//to transfer ownership, you should prefer pass by reference
//if all that's needed is modification of the value.
void PassByPointer(int* val)
{
	(*val) += 20;
}


7) Convert a string to int and vice versa in C++. Use of external lib is allowed.
*********************

//c++ string to int convert using lib
void StringIntConvertUsingSTD()
{

 	std::string str = std::to_string(20);

 	std::cout << str << std::endl;

	int i  = std::stoi("900");

	std::cout << i << std::endl;
}



8) Describe what the keyword const does? When and how is it used? 
	Which of the following are valid uses:

	"const int* p;
	int const* p;
	int* const p;
	const int* const p;
	const int const* p;
	const int const* const p;"

*********************

//When used with a variable:
//Const is used to prevent modificaiton of a value or pointer.
//Use in function and memeber decleration to ensure the 
//value remains un-modified throughout it's use.

void ConstCorrectness()
{
	int i1 = 0;
	int i2 = 1;
	int i3 = 2;
	int i4 = 3;
	int i5 = 4;
	int i6 = 5;

	const int* p1 		= &i1;		  //Pointer to constant int, Value pointed to by p1 CAN'T change.
	int* const p2 		= &i2;		  //Constant Pointer to an int, location pointed by p2 CAN'T change.
	const int* const p3 = &i3;		  //Constant Pointer to a constant int, Value and Location CAN'T Change.

	int const* p4		= &i4;		  // Same as const int*  , but looks and reads weird...
	const int const* p5 = &i5;		  //This works, but is redundant. Duplicate const decleration!
	const int const* const p6 = &i6;  //This works, but is redundant. Duplicate const decleration!


//	(*p1) = 20;  //INVALID
	p1 	  = &i2; //VALID

	(*p2) = 20;  //VALID
//	p2	  = &i1; //INVALID

//	(*p3) = 900; //INVALID
//	p3 	  = &i4; //INVALID
}


//When used with a function, it prevents the funciton from modifying values passed into it.
// ex.   void SomeFunction() const { /* values in this function can't change. */ }



9) Describe what a forward decleration is? Why is it useful?
*********************

  Instead of including a full header using:
  		 #include "HeaderFile.h"

  You simply decalre a class instead:
  		class HeaderFile;

  This allows the compiler to just treat the uses of that class as a pointer
  in the current file when doing initial header compilation pass.
  This can speed up header compilation times, and can also break cyclic include dependancies.
  It can only be used when the FULL type information of a class is NOT needed in the file.
  E.x. Just having pointer member variables.
  You won't be able to use it if the class depends on the header, in the case of inheritance 
  or struct ownership.




10) What does the explicit keyword do? How do you preform type conversion? What is the difference
	Between static_cast, dynamic_cast, and reintrp_cast?
*********************

//Type Conversion Example
class ExampleImplicitConversion
{

public:
	int data;

	//Since explicit is not used the compiler can do implicit conversions!
	ExampleImplicitConversion( int n ) : data(n) { }
};

class ExampleExplicitConstructor
{

public:
	int data;

	//Since explicit is used no implicit conversions!
	explicit ExampleExplicitConstructor( int n ) : data(n) { }
};

void ConversionExamples()
{
	//Valid, can use constructor implicitly.
	//But will cause '6' to be converted to ASCII int val 54.
	ExampleImplicitConversion ImplicitConvert = '6'; 

	std::cout << "Implicit Convert: " << ImplicitConvert.data << std::endl;

	//INVALID, constructor is explicit!!!
	//ExampleExplicitConstructor ExplicitConvert = '6'; 
	
	//Need to use constructor explicitly!!!!
	ExampleExplicitConstructor ExplicitConstruct(6); 
	
	std::cout << "Explicit Constructor: " << ExplicitConstruct.data << std::endl;


	//TYPE CASTING
	
	//Notes on casting types!!!
	//-----------------------------------

	//static_cast, used for most intuitive literal type conversions.
	//When used for inheritance does NOT return nullptr on invalid casts!!

	//dynamic_cast, used for most polymorphic or inherited casts
	//returns null ptr when fails.

	//const_cast, used to remove const.

	//C style cast (int) - Tries static_cast, then reintp_cast, also applies const_cast if needed.



	int testInt     = 10;
	float testFloat = 0.0f;
 
	int* testIntPtr     = &testInt;
	float* testFloatPrt = &testFloat;

	testFloat = static_cast<float>(testInt); //Valid, you can go from float to int

	std::cout << "Static cast: " << testFloat << std::endl;

	//INVALID, this is conversion doesn't make intuitive sense. 
	//Unless mangled a float* can't point to an int*.

	//testFloatPrt = static_cast<float*>(testIntPtr); 

	//reinterp cast lets you do whatever crazy shit you want!!!
	//this example treats the bits represented by (int)10 directly as a float!!!(1.4104 E-44)
	testFloatPrt = reinterpret_cast<float*>(testIntPtr);

	std::cout << "Reintrp cast: " << (*testFloatPrt) << std::endl;
}

//END Type Conversion Example


11) What do the mutable, volatile, and atomic keywords signify?
*********************

	-Mutable allows member variables of a class or struct to be changed EVEN WITHIN const functions!


	-Volatile signifies to the compiler that some EXTERNAL process may modify a value, so don't event try to optimize it (the compiler may remove a value deemed un-necessary during optimization.)



	-Atomic types are types that encapsulate a value whose access is guaranteed to not cause data races and can be used to synchronize memory accesses among different threads

	Objects of atomic types are the only C++ objects that are free from data races; that is, if one thread writes to an atomic object while another thread reads from it, the behavior is well-defined.

	In addition, accesses to atomic objects may establish inter-thread synchronization and order non-atomic memory accesses as specified by std::memory_order. These operations will be performed with std::memory_order_seq_cst, as this is the default order for all atomic operations in C++ 11.




12) What is an inline function? What is the magnitude of the speed difference between inline, direct, and virtual calls? Why would certain calls take much longer?
*********************

Pros:
When an inline keyword is used for a function it tells the compiler to direclty copy the contents of
a function 'inline' with wherever its called. This is opposed to just doing a direction function call(jumping).
This has the benefit of avoiding a function call overhead and pushing/poping variables.
Also this increases the locality of data and instructions used by the call, allowing for CPU to prefetch better.

cons:
This increases overall executable size. 
Can also increase compile times, since any code using an inline NEEDS to be recompiled 
(can't just jump to newly compiled funciton!)
B/c of increased executable size at call, may result in possible trashing if increased too large and casues page faults.

Speed Magnitudes:

3GHz in-order PowerPC CPU
1024 float vector3's  (fits in L1)  with 1000 additions:

inline  ~8ms
direct  ~68ms
virtual ~160ms

direct call takes longer because of one level of indirection needed. So CPU misses instruction prefetch once.
virtual calls takes even longer because of two levels of indirection. So CPU misses instruciton prefetch twice, AND needs to load data from the class that it's calling, so possible data cache miss.





13) What are the new and delete keywords used for? What is the difference between a shared_ptr, weak_ptr, and a unique_ptr?
*********************


The new keyword is used to request memory allocation from the language (off the heap) or if its large gets a full memory Page (from the OS).  The os gives our application 
some pages of virtual memory so new returns a virtual memory address that is within the 
application's range that maps to some physical memory in RAM. 
Delete is used to tell the language/OS to free/deallocate memory from use.

These work with raw pointers which needs all of its memory managed by 
hand and must be deleted when appropriate.

There are smart pointers which help memory management by using reference counting.

A unique_ptr represents a one owner pointer. 
Only the single owner can use the pointer. 
The pointer is cleaned up when that single owner leaves scope or is destructed.
It needs to be moved explicitly.

A shared_ptr keeps a reference counter and increments it whenever the pointer is passed. It decrements the counter
whenever the pointer leaves scope of a class or function. Once the coutner reaches 0, the pointer is automatically
flagged for deletion. Can cause issues with cyclic dependencies or data structs.

A weak_ptr just observes a pointer but does not increment its counter. It can become invalid.
So you much check if the underlying pointer has expired. 


14) Show an example of using a function pointer as a callback, delegate, or event. 
*********************

float ExampleDelegateConcreteFunc1(float arg)
{
	return (arg + 9.0f);
}

float ExampleDelegateConcreteFunc2(float arg)
{
	return (arg + 20.0f);
}

typedef float (*ExampleDelegate) (float arg);


void ExampleDelegateRun()
{
	float original = 20.0f;

	ExampleDelegate function = &ExampleDelegateConcreteFunc1;

	std::cout << "delegate1: " << function(original) << std::endl;

	function = &ExampleDelegateConcreteFunc2;

	std::cout << "delegate2: " << function(original) << std::endl;
}


15) What do the keywords  "extern c" signify?
*********************

when used with a function decleration:
 	extern "C" void func(int);

 Makes a function name in C++ have a C linkage.
 That means the compiler does not mangle the name of the function. 
 Which allows client C code to link and
 use your function by using a compatible header file that contains just
 the decleration of that function.


 16) What does the auto keyword mean in c++? 
     Use it with an iterator to loop over a std container.
 *********************

 //The auto keyword allows the type of the variable being delcared to be
 // automatically interpreted from its initializer.

 void RunItrExample()
{
	std::vector<int> myIntVec;

	myIntVec.push_back(1);
	myIntVec.push_back(5);
	myIntVec.push_back(8);

	for( auto iterator = myIntVec.begin(); 
		 iterator != myIntVec.end(); 
		 iterator++ )
	{
		std::cout << (*iterator) << " ";
	}

	std::cout << " iteraror!" << std::endl;
}


17) What is a namespace? When should it be used?
*********************

A namespace provides a method to place classes, functions, and variables  within a higher level scope.
This is useful to avoid naming conflicts within large projects or when importing external libraries.

You can identify namespace in each call by placing the namespace preceding 
the use of the object in the namespace  e.x.  std::cout, std::rand()... etc.


You can also specify the namespace to use within the header and sub-headers by placing a "using" decleration:

	//Dangerous! includes whole namespace, could lead to conflicts in sub-headers!!
	using namespace std; 

	//Type aliasing, Locally re-identify an object. Could lead to conflicts in sub-headers!!
	templace<class T>
	using MyVector<T> = std::vector<T>;



18) Name some STD data containers and their underlying data structure representation.
*********************

	std::array  		(statically sized array, contiguous) [c++11]
	std::vector 		(dynamically sized array, contiguous)
	std::deque			(double ended queue, non-contiguous)
	std::forward_list 	(single linked list, non-contiguous) [c++11]
	std::list			(doubly linked list, non-contiguous)

	std::stack			
	std::queue

	//Ordered associative containers. Sorted with BST, you can iterate!
	std::set 			(hashtable where value is key, uniqueness garunteed)
	std::multiset		(hashtable where value is key, multiples allowed)
	std::map 			(hashtable key=>value, uniqueness garunteed)
	std::multimap	    (hashtable key=>value, multiples allowed)

	//Unordered versions are just unordered_X  (faster to access, can't directly iterate)



19) Whats the difference between a struct and a class?
*********************
For the most part, nothing.
You can do anything with a struct that you can do with a class.

The only real difference:
Structs are public by default. 
Classes are private by default.


In practice (depends on the company):

Structs are generally used to represent 
smaller types that mostly consist of plain old data.

Class are generally larger and represent more functionality.


20) Give an example of using a template. How do they work udner the hood?
	What are the pros and cons of using templates?
*********************

template<class t1>
class TemplatedLinkedListNode
{

public:

	explicit TemplatedLinkedListNode(t1 argData) : data(argData), Next(nullptr) {}

	TemplatedLinkedListNode *Next;
	t1 data;
};

void RunTemplateExample()
{
	TemplatedLinkedListNode<int> n1 (10);
	TemplatedLinkedListNode<int> n2 (20);
	TemplatedLinkedListNode<int> n3 (40);

	n1.Next = &n2;
	n2.Next = &n3;

	TemplatedLinkedListNode<int>* current = &n1;

	while(current != nullptr)
	{
		std::cout << "template node: " << current->data << " ";
		current = current->Next;
	}

	std::cout << std::endl;
}


//Templates allow for the same code to be used for many differing types of objects
//Increasing the code's modularity and usability.
//The compiler duplicates the template code across all 
//the types that it finds using the template. 
//New code is generated for each new type that the compiler encounters.
//This can cause both the compile time and executable size to increase significantly.



21) Describe some integral data types and their sizes and max capacities
*********************

bool   (1 byte)  (8 bits)  [256 max 2^8]
char   (1 byte)
short  (2 bytes) (16 bits)  
ushort (2 bytes)			[65,536 max 2^16]
int    (4 bytes) (32 bits)  //At least 2 bytes, can be 4 bytes, compiler target specific
float  (4 bytes) 
uint   (4 bytes)			[4,294,967,296 max 2^32]
long   (4 bytes) //At least 4 bytes
ulong  (4 bytes)			
double (8 bytes) (64 bits)
int64  (8 bytes)
long double (8 bytes)
long long   (8 bytes) //at least 8 bytes
long ulong  (8bytes)			[18,446,744,073,709,551,616 max 2^64]


22) Give an example of operator overloading.
*********************


class ComplexNum
{

private:
	ComplexNum(){}

public:
	int real;
	int imaginary;

	ComplexNum(int argReal, int argImaginary): real(argReal), imaginary(argImaginary){}

	ComplexNum operator + (ComplexNum const &obj)
	{
		ComplexNum res;
		res.real 		= real + obj.real;
		res.imaginary   = imaginary + obj.imaginary;

		return res;
	}
};

void RunOperatorOverloadTest()
{
	ComplexNum c1 (10, 5);
	ComplexNum c2 (2, 4);

	ComplexNum c3 = c1 + c2;

	std::cout << "overload: " << c3.real << "," << c3.imaginary << std::endl;
}




3D Math Specific Questions
--------------------------------


23) Describe what a vector is in 3d space?
*********************
	A vector is a representation of a direction with a magnitude. 
	It has no origin and represents the same direction and magnitude 
	throughout the entire space. 

	You can add and subtract vectors to points to move them. 
	Subtracting two points from one another gives a vector
	representing the displacement.

	P1 (xp1, yp1, zp1) 
	P2 (xp2, yp2, zp2)

	P2 - P1 = Vd (Displacement vector, pointing from P1 towards P2)


	Adding two vectors places them head to tail with
	the resulting addition being the vector that meets the combined tail to
	the combined head. Subtracting two vectors places them tail to tail with
	the resulting subtraction being the vector that meets from one head to the other.

	A unit vector is a vector with  a total magnitude of 1.0.

	V1 <x1, y1, z1>    V2 <x2, y2, z2> 

	V1 + V2 = <x1+x2, y1+y2, z1+z2>


24) What is the magnitude of a vector? How do you compute it?
*********************

	The magnitude of a vector is the scalar length of the vector.
	If mulitplied into a Unit Vector would give you the same vector
	that you got the magnitude from.

	To calculate the magnitude of a vector:

	|A| = sqrt( Ax^2 + Ay^2 + Az^2)


25) What does it mean to normalize a vector? How do you compute it?
*********************
	Normalizing a vector means to make the total magnitude of
	the original vector length 1. This means the vector represents
	purely a direction without any addition magnitue (unit length).

	To compute it first you find the vector's Magnitude |A|.
	Then you preform the following:

	Ax = Ax / |A|
	Ay = Ay / |A|
	Az = Az / |A|



26) What is a vector dot product? How do you calculate it?
*********************

The vector dot product takes two vectors and computes 
the length of the projection of one onto the other.

To calculate the Dot product:

A • B = (Ax + Bx) * (Ay + By) * (Az + Bz)


In addition, it's geometric defintion can be represented as:

A • B = |A| * |B| * cos(Θ)

Where theta is the angle between the vectors.



27) What is a vector cross product? How do you calculate it?
*********************

A cross product between two vectors gives you a third vector
that is perpendicular to both. Since there can be two of these
(upfacing and downfacing) you need to choose if the space is
right hand oriented vs left hand oriented and choose accordingly.

upface: 	AxB
downface:   BxA == -AxB

To calculate the Cross product:

AxB = < Ay*Bz - Az*By, Az*Bx - Ax*Bz, Ax*By - Ay*Bx>


In addition, it's geometric definition can be represented as:

AxB = |A| * |B| * sin(Θ) * n

where theta is the angle between A and B
where n is the unit vector perpendicular to both A and B


28) Find the angle between two vectors (A,B).
*********************

First find the magnitudes of A and B (|A| |B|).
Then calculate their dot product (D).

Using the geometric definition of a dot product we can find the angle.

D = |A|*|B|*cos(Θ)

D / (|A||B|) = cos(Θ)

Θ = arccos ( D / (|A||B|) )


29) Multiply a single scalar value (s) into a vector (A)
*********************

s * A = < s * Ax, s * Ay, s * Az>


30) Given three non-colinear points (Pa, Pb, Pc)
	Create a representation of a plane.
*********************

	A plane requires a normal to represent its slope.
	So first we need to get two vectors on the plane to do a cross product.

	Va = Pa - Pb
	Vc = Pc - Pb

	Vn = Va x Vc

	Normalize Vn, this is the normal of the plane.

equation of a plane is:

ax + by + cz = d    [a,b,c] is the normal

Then use the normal vector and any point to find the final determinant d.


31) Given a formula for a plane and a vector (V).
	Find the projection of that vector onto the plane.
*********************

equation of a plane is:

ax + by + cz = d

So the plane normal Pn = <a,b,c>

To find the projection:

First we take the dot product of the
vector and the normal to find the magnitude of the projection.
(V • Pn)   <------ scalar representing magnitude.

Then we subtract the original vector from the planes normal vector 
to get the direction of the projection along the plane. 
(Line up the tails, and find the vector between the heads)

V - Pn   <--- vector representing direction along plane.


Finally we combine the two giving us the final equation:

Projection = (V - Pn) * (V • Pn)



32) Given a plane normal (Pn), a point on that plane (P1), 
	and a second arbitrary point(P2).
    Can you find out what side of the plane the point lies on.
*********************

	First find the vector between P2 and P1.

	Dv = P2 - P1

	Then take the dot product of that and the Plane normal

	CrossP = Pn • Dv


	If its + then its on the side of the normal.
	If its - then its opposite the normal.
	If its 0 then the point is ON the plane.


33) Given two spheres in 3d space (represented by center point and radius)
	Sc1 (x,y,z) Sr1   and  Sc2 (x,y,z) Sr2 
    Find out if they overlap.
*********************


The equation of a sphere with center (h,j,k) and radius r :

(x - h)2 + (y - j)2 + (z - k)2 = r2


But we can just find the displacement of the center's Sc1 - Sc2
Then get the magnitude of the displacement

|Sc1 - Sc2|

Then compare by adding the two sphere radii
|Sc1 - Sc2| - (Sr1 + Sr2)

If the result is + then they don't overlap
If the result is - then they overlap
If the result is 0 then they are exactly touching.



34) Point to AABB Overlap
*********************

Simply get the displacement from point to sphere center.
Then check its magnitude against radius. 

If larger then its not overlapping.
If smaller then its overlapping.
If 0 then its on the sphere.


35) AABB to Sphere Overlap
*********************

You could check all points but this is overkill.
Find the point CLOSEST to the sphere center.

Then run a Point to AABB overlap on that closest point.

If the box is not axis alinged, then you rotate the sphere
such that it becomes axis alinged with the box, 
then run the overlap test.


36) AABB to AABB Overlap
*********************

 Similar to the point to AABB Overlap test, but we need to do one test
 PER Axis. Check the min and max of each axis point againt one another.

 So it looks like:

Instersects(A,B)=     (AminX <= BmaxX && AmaxX >= BminX)
		 		   && (AminY <= BmaxY && AmaxY >= BminY)
		 		   && (AminZ <= BmaxZ && AmaxZ >= BminZ)



37) What is a Quaternion? Why is it useful?
    Show how to convert between the following:
    	Angle Axis     <=> Quat
    	Euler Angles   <=> Quat
    	4x4 Rot Matrix <=> Quat

    Describe these:
    	Identity Quat
    	How to combine Quats?
    	How to find inverse of a Quat? Why its useful?
*********************

A quaternion is a complex number (real and imaginary) with 4 Dimensions.
They satisfy the equation:

	i2 = j2 = k2 = ijk = −1 


Quaternions are generally represented in the form:

a + bi + cj + dk

where a, b, c, and d are real numbers, and i, j, and k are the fundamental quaternion units.


When used in games they are used to accurately and succinctly
represent rotations. They do this by reprensenting rotation 
as a point along a unit 4D hyper-sphere. Because of this 
they solve the issuue of Gimbal Lock (two axis align during a three axis rotation).

As an illustration

				Details Of space 			 				Ways to represent Rotation
------------------------------------------------------------------------------------------------
# Axis of Rotation   Spatial Dimensions  ||  Euler Representation      Point on Unit Sphere
       1                    2D           ||      1 Angle (x)              2 values P(x,y)
       2                    3D           ||      2 Angles (x, y)          3 values P(x,y,z)
       3                    3D           ||      3 Angles (x, y, z)       4 values P(x,y,z,w)


Some use Quaternion definitions (assumes Z up):

Unrotated   < 0, 0, 0, 1 >
Yaw 180     < 0, 0, 1, 0 > (rotation about z-axis)
Pitch 180	< 0, 1, 0, 0 > (rotation about y-axis)
Roll 180	< 1, 0, 0, 0 > (rotation about x-axis)


From there you combine and normalizae quaternions to get every rotation possible.

Multiplication is NON-Commutation ij = k  but ji = -k.
Multiplying two quaternions COMPOSES their rotations (preform one then preform the other).
Multiply by the inverse quaternion will return you to the original rotation.


Table For multiplication

×	1	i	j	k
--------------------
1|	1	i	j	k
i|	i	−1	k	−j
j|	j	−k	−1	i
k|	k	j	−i	−1


Example code for operations on a Quat:

public final void mul(Quat4d q1,Quat4d q2) 
{
    x =  q1.x * q2.w + q1.y * q2.z - q1.z * q2.y + q1.w * q2.x;
    y = -q1.x * q2.z + q1.y * q2.w + q1.z * q2.x + q1.w * q2.y;
    z =  q1.x * q2.y - q1.y * q2.x + q1.z * q2.w + q1.w * q2.z;
    w = -q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w;
}

public final void normalise() 
{
    double n = Math.sqrt(x*x + y*y + z*z + w*w);
    x /= n;
    y /= n;
    z /= n;
    w /= n;
}

public final void add(Quat4d q1,Quat4d q2) 
{
    x = q1.x + q2.x;
    y = q1.y + q2.y;
    z = q1.z + q2.z;
    w = q1.w + q2.w;
}

public final void scale(double s){
    x *= s;
    y *= s;
    z *= s;
    w *= s;
}
  
public final void inverse(Quat4d q1) 
{
    x = -q1.x;
    y = -q1.y;
    z = -q1.z;
    w = q1.w;
  }

void AngleAxisToQuat(Axis, angle)
{
	qx = ax * sin(angle/2)
	qy = ay * sin(angle/2)
	qz = az * sin(angle/2)
	qw = cos(angle/2)
}

void QuatToAngleAxis( Quat)
{
	//Watch for divide by zero

	angle = 2 * acos(qw)
	x = qx / sqrt(1-qw*qw)
	y = qy / sqrt(1-qw*qw)
	z = qz / sqrt(1-qw*qw)
}

void EulerToQuat()
{
	double c1 = Math.cos(yaw/2);
    double s1 = Math.sin(yaw/2);
    double c2 = Math.cos(pitch/2);
    double s2 = Math.sin(pitch/2);
    double c3 = Math.cos(roll/2);
    double s3 = Math.sin(roll/2);
    double c1c2 = c1*c2;
    double s1s2 = s1*s2;

    w =c1c2*c3 - s1s2*s3;
  	x =c1c2*s3 + s1s2*c3;
	y =s1*c2*c3 + c1*s2*s3;
	z =c1*s2*c3 - s1*c2*s3;
}

public void QuatToEuler(Quat4d q1) 
{
	double test = q1.x*q1.y + q1.z*q1.w;

	if (test > 0.499) 
	{ 
	   // singularity at north pole

		yaw = 2 * atan2(q1.x,q1.w);
		pitch = Math.PI/2;
		roll = 0;
		return;
	}
	if (test < -0.499) 
	{ 
	    // singularity at south pole

		yaw = -2 * atan2(q1.x,q1.w);
		pitch = - Math.PI/2;
		roll = 0;
		return;
	}

    double sqx = q1.x*q1.x;
    double sqy = q1.y*q1.y;
    double sqz = q1.z*q1.z;

    yaw   = atan2(2*q1.y*q1.w-2*q1.x*q1.z , 1 - 2*sqy - 2*sqz);
	pitch = asin(2*test);
	roll  = atan2(2*q1.x*q1.w-2*q1.y*q1.z , 1 - 2*sqx - 2*sqz)
}


void MatrixToQuat(Matrix4f m1)
{
	w = Math.sqrt(1.0 + m1.m00 + m1.m11 + m1.m22) / 2.0;

	double w4 = (4.0 * w);
	x 		  = (m1.m21 - m1.m12) / w4 ;
	y 		  = (m1.m02 - m1.m20) / w4 ;
	z 		  = (m1.m10 - m1.m01) / w4 ;
}

public final void quatToMatrix(Quat4d q)
{
    double sqw = q.w*q.w;
    double sqx = q.x*q.x;
    double sqy = q.y*q.y;
    double sqz = q.z*q.z;

    // invs (inverse square length) is only required if quaternion is not already normalised
    double invs = 1 / (sqx + sqy + sqz + sqw)
    m00 = ( sqx - sqy - sqz + sqw)*invs ; // since sqw + sqx + sqy + sqz =1/invs*invs
    m11 = (-sqx + sqy - sqz + sqw)*invs ;
    m22 = (-sqx - sqy + sqz + sqw)*invs ;
    
    double tmp1 = q.x*q.y;
    double tmp2 = q.z*q.w;
    m10 = 2.0 * (tmp1 + tmp2)*invs ;
    m01 = 2.0 * (tmp1 - tmp2)*invs ;
    
    tmp1 = q.x*q.z;
    tmp2 = q.y*q.w;
    m20 = 2.0 * (tmp1 - tmp2)*invs ;
    m02 = 2.0 * (tmp1 + tmp2)*invs ;
    tmp1 = q.y*q.z;
    tmp2 = q.x*q.w;
    m21 = 2.0 * (tmp1 + tmp2)*invs ;
    m12 = 2.0 * (tmp1 - tmp2)*invs ;      
}



38) Matrices What are they? Why are they useful?

	Row major order vs column major order?

	Show how to:
	Translate, Scale, Rotate a Matrix, 
	Add (same dimensions), 
	Add (differing dimensions),
	Transpose,
	Multiply
	Get the inverse 

	Show how to extract:
	Position, euler angles, scale

	What is the Identity Matrix?
*********************

A matrix is a rectangular array of numbers or expressions
organized in columns and rows. They are used to represent 
linear transfomations in a generlized way. In this way
they are used in games to compose heirarchys of
translations, rotations, and scalings in a concise
and effecient way.

Ex:
[
 e11  e12  e13
 e21  e22  e23
]

Row order (C  array 0-indexed) 
Better locality generally, this is whats mostly used. 
All examples assume this.
-------------
a00(e11) a01(e12) a02(e13)
a10(e21) a11(e22) a12(e23)


Column Order (c array 0 indexed)
-------------
a00(e11) a10(e21) a01(e12)
a11(e22) a02(e13) a12(e23)


To translate an object by a vector v, each homogeneous vector p 
(written in homogeneous coordinates) 
can be multiplied by this translation matrix:

[
  1  0  0  v_x 
  0  1  0  v_y 
  0  0  1  v_z 
  0  0  0  1
]


A scaling can be represented by a scaling matrix. 
To scale an object by a vector v = (vx, vy, vz), 
each point p = (px, py, pz) would need to be multiplied with this scaling matrix:

[
  v_x  0   0  0 
   0  v_y  0  0 
   0   0  v_z 0 
   0   0   0  1
]


Rotation in 2D:
(counter-clockwise)
[
   cos(Θ) -sin(Θ)
   sin(Θ)  cos(Θ)
]

(clockwise)
[
   cos(Θ)   sin(Θ)
   -sin(Θ)  cos(Θ)
]


Rotation in 3D using the angle Θ and the unit vector <x, y, z>:
[
	xx(1-cosΘ) + cosΘ     yx(1-cosΘ)-zsinΘ   zx(1-cosΘ)+ysinΘ
	xy(1-cosΘ) + zsinΘ    yy(1-cosΘ)+cosΘ    zy(1-cosΘ)-xsinΘ 
    xz(1-cosΘ) - ysinΘ    yz(1-cosΘ)+xsinΘ   zz(1-cosΘ)+cosΘ
]



Adding Matrices, MUST BE Same Dimensions

Matrix 1:
2	5	1
4	-3	7
5	8	6

Matrix 2:
4	6	-2
-1	5	3
9	0	4


To add these matrices, simply get the value of each element from both matrices, and add them together:

(2+4) = 6	    (5+6) = 11	    (1+ -2) = -1
(4 + -1) = 3	(-3 + 5) = 2	(7+3) = 10
(5+9) = 14	    (8+0) = 8	    (6+4) = 10


Matrix 1 + Matrix 2:
6	11	-1
3	2	10
14	8	10


Subtracting is the same, but you subtract instead of add. (MUST BE same Dimensions)


Multiplying matrices:

For each element in the new matrix,
multiple the row * column, then add them all up
Ex:

[
  a  b
  c  d
]

[
  w  x
  y  z
]

=

[
  aw + by   ax + bz
  cw + dy   cx + dz  
]

Multiplying matrices with differing dimension CAN BE DONE 
But they MUST HAVE same number of rows and columns. The 
resulting matrix will cancel out the dimensions that are equal.
So the final matrix will have sections of the differing dimension

4x2 Matrix * 2x3 Matrix =  4x3 Matrix

NO DIVISION!

Identity Matrix
Diags of 1's
[
  1  0  0
  0  1  0
  0  0  1
]



Inverse Matrix
For a 2x2 its easy, flip one set of diagnols
then negate the other set, then multiply by a determinant.
For other order matrix, a more complex method is needed.
Look at Gauss-Jordan Elimination

[
  a  b
  c  d
        ] ^ -1

=

1 / (ad-bc) *

[
	d  -b
   -c   a
]



Data Structure Questions
--------------------------------


39) Describe what an array is? What are some of its properties and
    complexities?
*********************

	An Array represents a set of elements stored in contigous memory.
	Generally their size is fixed but there are structures that can
	make dyanmically sized arrays. Elements are axed by using some offset (index)
	that is added to the original pointer. A[0] is the first element.
	Good for cache locality!

	With no resizing
	Insertion at an index is O(1)
	Deletion or nulling at index is O(1)
	Access at indes is O(1)

	With rezising:
	Insertion in middle while maintaining order with resize is O(n/2) (need to shift!)
	Deletion from middle while maintaining order with resize is O(n/2) (need to shift!) 
	Deletion where you don't care about order is O(1) by swapping with last element
	then deleting last element and resize.




40) Describe what a linked list is? How to implement? What are its pros and cons?
    What are some operations on a linked list? Big O? How to find a cycle?
*********************

 A linked list represents data elements that are chained together using pointers.
 They are not contiguous in memeory and are bad for cache locality.

 class LinkedListNode
{

public:
	LinkedListNode* Next;
	//LinkedListNode* Previous; Doubly linked list.
	int data;
};


Indexing O(n)  have to loop through
Insert   O(1)  need to make sure not to lose a link while swapping next pointers.
Delete   O(1)   ^^^ same caution as insert
space    O(n)  each data element needs an additional pointer!


//Discover if a linked list has a cycle by using the
//Tortise and hare method. In a cyclic list the faster
//Moving pointer has to eventually catch up to the slower moving pointer.
bool HasLoop(LinkedListNode* First)
{

	if (First == nullptr)
	{
		return false;
	}

	LinkedListNode* slow;
	LinkedListNode* fast;

	slow = fast = First;

	while (true)
	{
		slow = slow->Next;

		if (fast->Next != nullptr)
		{
			fast = fast->Next->Next;
		}
		else
		{
			return false; //Found an end point
		}

		if (slow == nullptr || fast == nullptr)
		{
			return false; //Found an end point
		}

		if (slow == fast)
		{
			return true; //the faster pointer has caught up with the slower, found a cycle.
		}
	}
}


41) Describe a stack. How to implement it? Pros, Cons?
    Operations and their complexities?
*********************

 A stack is a Last In, First Out structure (LiFo). 
 Underlying it can be represented either using a dynamically 
 sized array or linked list with some reference to the TOP.

 For the most part all stack operations are O(1). 
 Size is also O(1) [Unless using linked list as underlying]

 Push: Pushes an element onto the stack and moves top index upward.
 Pop:  Pops an element off the top of the stack, moves index downward.

 Function calls can be emulated using a Stack (push arguments on, then pop off).
 In this way a stack can be used to unroll recursive functions.



42) Describe a Queue. How to implement it? Pros, Cons?
    Operations and their complexities?
*********************  

 A queue is a First in, First out structur (FiFo).
 Underlying it can be represented either using a dynamically sized
 array or linked list with some reference to the Head and Tail.

 For the most part all queue operations are O(1). 
 Size is also O(1) [Unless using linked list as underlying]

 Enqueue: Adds an element to the Tail of the queue. Advances tail pointer.
 Dequeue: Removes an element from the Head of the queue. Advances head pointer.
 
 Queues are commonly used as buffers when there is an differing rates 
 between consumption of a resource and its generation. Also they can be useful
 for job tasking / scheduling when not all jobs can be run simultaneously.



43) Describe a Binary Search Tree. How to implement it? Pros, Cons?
    Operations and their complexities?
*********************

A binary tree is a data structure where each node
has at most two children (left child, right child)

the left child must be of  less or equal   value than the parent.
the right child must be of higher or equal value than the parent.

they are useful because of their effecient searching and sorting. 
Typically O( log n). However if insertion is done in perfect order 
(1,2,3,4,5....) the tree becomes DEGENERATE and search approaches O(n).
In order to fix this the tree needs to Self-Balance in some way.
Look at a red/black tree for simple balancing (marks a node as red or black)



class TreeNode 
{
public:
	explicit TreeNode(int argKey) : key(argKey) { }

    int key;
    TreeNode *left;
    TreeNode *right;
};

TreeNode* bst_insert(TreeNode*& root, int key) 
{
  if (!root)
  {
    root = new TreeNode(key);
  }
  else if (key < root->key)
  {
    root->left = bst_insert(root->left, key);
   }
  else
  {
    root->right = bst_insert(root->right, key);
  }
  
  return root;
}

TreeNode* bst_search_recursively(int key, TreeNode* node)
{
     if (node == nullptr || node->key == key)
     {
         return node;
     }

     if( key < node->key )
     {
         return bst_search_recursively(key, node->left);
     }
     else 
     {
     	return bst_search_recursively(key, node->right);
     }
}

void bst_traverse_in_order(TreeNode* node)
{
    if( node == nullptr)
	{
        return;
    }
    
	//Changing order of access changes traverse type

    //std::cout << node->key << ","; //Pre-Order

    bst_traverse_in_order(node->left);
    
    std::cout << node->key << ",";  //In-Order (sorted)

    bst_traverse_in_order(node->right);

    //std::cout << node->key << ","; //Post-Order
}

void RunBinaryTreeExample()
{
	TreeNode* root = new TreeNode(5);

	bst_insert(root, 2);
	bst_insert(root, 50);
	bst_insert(root, 1);
	bst_insert(root, 7);
	bst_insert(root, 9);

	TreeNode* Found = bst_search_recursively(50, root);

	if(Found != nullptr)
	{
		std::cout << "Bst search found: " << Found->key << std::endl;
	}
	else
	{
		std::cout << "bst search found nada" << std::endl;
	}

	Found = bst_search_recursively(90, root);

	if(Found != nullptr)
	{
		std::cout << "Bst search found: " << Found->key << std::endl;
	}
	else
	{
		std::cout << "bst search found nada" << std::endl;
	}

	bst_traverse_in_order(root);
	std::cout << std::endl;
}


44) Describe a Heap. How to implement? pros, cons?
    Operations and their complexities
*********************

https://www.tutorialspoint.com/data_structures_algorithms/heap_data_structure.htm

???????? TODO FINISH Question ????????


45) Describe a Hashtable. How to implement? pros, cons?
    Operations and their complexities
*********************


???????? TODO FINISH Question ????????


45) Describe a Dynamic Sized Array. How to implement? pros, cons?
    Operations and their complexities
*********************


???????? TODO FINISH Question ????????




Algorithm Specific Questions
--------------------------------


45) Give an algorithm to swap two values
    without using a temporary variable.
*********************

//Use XOR swap method that takes advantage of Commutative property.
void XORSwap(char& x, char& y)
{
	x ^= y;
	y ^= x;
	x ^= y;
}



46) Give an algorithm to add two values without using
    any of the following operators (+, -, *, /, %)
*********************

//Add in a similar way that ALU's add.
//use XOR and bitshift when there is a carry.
int XORAdd(int x, int y)
{
    // Iterate till there is no carry  
    while (y != 0)
    {
        // carry now contains common set bits of x and y
        int carry = x & y;  
 
        // Sum of bits of x and y where at least one of the bits is not set
        x = x ^ y; 
 
        // Carry is shifted by one so that adding it to x gives the required sum
        y = carry << 1;
    }
    return x;
}


47) Reverse a string using any method. 
    Then reverse it in-place
*********************

//Reverse a string using any method.
//Just allocate the exact amount of space as the other string,
//Then iterate through it in reverse and place last element first.
std::string ReverseString(std::string StrToReverse)
{
	std::string ToReturn = StrToReverse;

	for (int i = StrToReverse.length() - 1; i >= 0; i--)
	{
		int SwapIndex		  = (StrToReverse.length() - 1) - i;
		ToReturn[SwapIndex] = StrToReverse[i];
	}

	return ToReturn;
}

//Reverse a string with no secondary array or storage. 
//Use XOR swap method that takes advantage of Commutative property.
//Since we're swapping, meet in the middle to avoid overswapping....
//Which would have happened if you used the above code.
void ReverseStringInPlace(std::string& StrToReverse)
{
	int right = StrToReverse.length() - 1;
	int left = 0;
	while (left < right) 
	{
		StrToReverse[right] ^= StrToReverse[left];
		StrToReverse[left]  ^= StrToReverse[right];
		StrToReverse[right] ^= StrToReverse[left];

		++left;
		--right;
	}
}


